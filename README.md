# ProgramKeyQuestionThinking

## Mindset

### 代码阅读
+ `var1.var2.func1()`： 无论是`var1`或`var2`或`var1.var2`本质上都是一块内存空间，`func1()`本质上是指明cpu计算逻辑的一系列操作。

### 理解程序和现实的关系
+ 计算机程序是运行在内存中的，程序或变量本质上是内存上的一段空间，空间上保存着可变或不可变的数据，而我们**对数据赋予了概念和意义**
+ **所谓的技术**是指概念、协议和处理逻辑，可以对内存空间的赋予技术概念和利用数据变化达到技术实现的目的，这就是**计算机可以模拟现实世界**的原因
  + **概念**就是对内存的一段区域赋予抽象的含义。
    + 各式各样的类型或者概念叫法，这是为了实现一些机制和技术，例如安全、网络、性能效率等等
    + 处理逻辑就是算法和约定的协议、配置的处理原则
+ 我们关注的是**内存**！
  + 我们是在内存中“活动”，**计算机的每一个部分（或者说每一个物理设备）在内存中都有一块空间代表它**，所有计算机可以**模拟整个世界**
### 类和实例
  + 要理解好**实例（占据内存空间，如变量）**、**类型（抽象概念）**、**值（抽象概念）** 这三者的区别和关系 
  + class相当于规制了一种数据类型，**类型**代表着其对象可以支持的一系列操作和包含的数据，但类型没有占据内存空间，只有用它实例化的变量才会占据内存空间（用到了才会占据内存），**但是它可以执行一些初始化流程(例如Class.forName注册驱动，static静态初始化块要执行)**。
  + ***类型***可以分为三大类：值类型（内存直接**保存内容的层面**）、指针类型（内存**保存内存地址层面**）、引用类型（**介于内存保存地址和内存保存内容两个层面之间**。）
  + **static静态** 这个概念是和动态是相对的。动态指每个类生成的一堆实例是各不相同的，它们各有自己的内存地址和字面值，并且申请内存地址是有随机性的，所以便有了一种**动态的含义**在里边。因此，静态修饰的变量就是指该变量或者方法不需要申请实例内存就可以使用（但是还是需要有类内存），再往下延伸，就是**不需要实例化就能调用**，即**类就可以直接调用**。所以，**没有static修饰的也叫作实例的私有变量，有static修饰的也叫类变量，由所有实例共享**。
  + **为什么main方法必须是staitc？** 由于Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public，又因为Java虚拟机在执行main()方法时**不必创建对象**，所以该方法必须是static的，该方法接收一个String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数。
  + **类当中**可以使用类。
### 字面量
  + 字面量指的是：字面的意思就是它的值，和变量相对。
    + **`'a'`字面量**的字面是a，值就是a
    + **a变量**的字面是a，**值要看其保存的内容**
### 变量
  + **变量本质**上是一块内存区域。变量的值的变化实质是指在该内存区域的电位变化。
  + **一种类型的变量在内存上保存的到底是什么？** 抓住这一点即能明白变量间值的传递 变量之间互相是否会影响等等问题。 有的变量是直接放值，有的是间接放值（指针和引用）。
  + **变量之间的传递无论是实参到形参，或是实参到实参，都是把一个变量自身保存的内容在另一个变量身上完整复现**。只不过如果保存的内容是基本数据类型，则另一个变量复现出基本的数据类型，两个变量之间不会有影响。如果保存的内容是引用类型，则另一个变量复现出的也是该引用，根据引用的性质，这两个变量都指向了同一个内存空间，自然对其中一个操作，会影响另外一个的使用。所以**关键是看，一个变量保存的到底是基本数据类型，还是引用类型。**
  + 这里要理清一点：变量本身在内存空间上有一个地址，变量保存的引用对应的是内存空间上的另一个地址，所以一个保存了引用对象的变量会涉及到两个内存地址。
### **方法的签名为啥设计成仅包括方法名称和参数？** 
  + 从**调用者的角度**来看更好理解，调用者只要能调用到匹配的方法就行，不用关心返回值的类型，所以方法的签名不用考虑返回值。
  + **覆写**要求两者完全一致（包括返回类型，方法签名等等）；**重载**则只要求方法签名一致即可
### 访问权限与权限开放考虑
  + “访问”指的是使用对象、方法的人能否读取到值、能否使用这个功能的权限，而不是指对象能否访问自己的数据和方法。并且，这个权限和当前代码所在的位置、区域有关。
  + **在设计类写public，private之类的权限时，考虑的是要不要把这个东西暴露给外部（外部指该类实例、子类、其他类、其他包等等）**。
### Java没有指针，只有引用的理解
  + 除了基本类型的变量直接保存的是“值”（**内容**），用于数组和类实例化的变量保存的是“地址值”（**内容在他处，保存的是一种指向**），**new命令会在他处开辟堆内存保存具体内容**，再把这种指向指派给该变量，这种间接性便有了“引用”的意味，这也是为什么**引用类型的变量必须用new进行初始化**的原因。
  + 从另一个角度来看，就是JAVA不去考虑变量本身的地址值，因为**我们需要的值都存在了别的地方**，通过引用的方式和变量产生关联，不用太关心变量本身在内存中的位置。但是**其他类型的语言，变量本身就是保存我们需要的值，所以我们要关注这个变量的内存地址，也就是指针。**
  + **对象和基本数据类型的区别**，基本数据类型比如整型是被共享的，具体去看 a=1 和 b=1，实际上都是1这个值在保存在堆内存中，a和b保存的是同一个堆内存的地址，它们指向了同一个地方，这样一来就可以节省内存空间。但是对象不同，每一个对象都开辟在堆内存中，a=new obj() , b= new obj(), 是属于两个不同的对象，a和b保存的是不同堆内存的地址。所以从这一点上去看，值传递和引用传递本质上都是地址传递。
### 继承的作用
  + **最有用的功能是`向下转型`，这种方式使得一个父类变量可以保存一个子类实例的引用，并且调用子类的方法。（这种思想延伸到了一个接口类型的变量可以保存一个实现了该接口的类的实例的引用），也就是在写方法的参数时，我们可以把形参设置成父类类型（接口类型同理），该方法不光能接收父类实例，也能接收子类实例（接口类型同理）**
  + 可以用一个接口变量保存一个实现了该接口的类的实例，而在**其他地方只要规定只接收该接口变量**。这样一来相当于就是**只要实现了该接口的任何实例都可以被接收**。这个**本质上是向上转型的应用**
  + **为什么父类变量可以保存子类引用而子类变量不可保存父类引用？** 因为我们往往需要实例化一个功能更加丰富的对象，引用的产生便是进行了实例化，因为功能更加丰富子类会比父类更加合适，实例化一个父类对象则不是最好的选择。接口同理。
### 抽象类的用途
  + 抽象类的用途就是把**多个子类**共用的功能给实现了，**每个子类只需要实现自己关注的功能（即覆写）**。(HttpSeverLet抽象类对ServerLet接口的封装就是这种思想）
### 接口是规范，不是执行流程！
  + 接口仅仅是一份规范，要更关注实现了接口的具体类及其实例。
  + 更容易的理解是，**接口=能力**，**实现接口=具备能力**。
  + **“轮子”的执行流程和接口无关，执行流程是由具体类去执行，“轮子”会要求这个类需要具备一些能力，能力就是接口规范，具备能力就是实现接口规范**。
  + 在代码中，我们经常用一个接口变量调用接口中定义的方法，看起来是这个接口变量在起作用。但是，真正起作用的是接口变量保存的-实现了该接口的-具体类的-实例，我们更应该去关注实例本身才对。
  + 接口的出现，让一个接口变量可以接收的范围不再局限于某一类，而是只有具备接口规范规定的能力就可以被接收。
### 类加载
  + .class文件可以等程序跑起来了再通过反射机制载入，这种机制提供了一种入口思路，可以让开发者自行开发.class文件嵌入到自身的框架中。
  + Class.forName会把目标类装载到内存中，并且类中的普通代码块和static代码块会执行。
### 进程和线程
  + 进程即**资源**，线程即**执行**，所以**main自身也是一个线程**。
  + **线程对象**就是一个记录了执行流程的对象（**没错，每个线程都是一个具体的对象**），它相当于一个掌握了执行流程的执行人，我们要执行什么任务就让它去替我们执行。
  + 实现了runnable接口的类像是**线程的配置文件**（这个类也可以视为普通类，run方法也可以直接被这个类的实例调用)，**它的实例无法作为一个线程对象**，**这个类实例化后的对象如果给多个线程使用，则多个线程共用同一份配置文件（共享资源）**。
  + 用了synchronized修饰符的类**并不一定非得是线程类，可以是普通类**。这个修饰符**只是在描述当这个类在碰到多个线程处理自身实例化的对象时，该对象应该做出怎样的操作**。
  + 标记后的代码块在任何线程中被执行时都要保持**原子性**，被它修饰的方法或者对象是要对不同线程的调用起反应的。
### I/O流
  + I/O流一种让数据流通的媒介工具，好比内存和外设之间的数据线（总线）。
  + **程序是跑在内存的**，所以程序io操作是在内存开辟一段空间和存储设备进行交互。换言之，你new一个file对象时，它**仅仅是在内存中对存储设备上的目标文件进行标识，表示目标在哪儿，之后需要再利用流对象IO机制控制数据在内存和io设备之间流动（流进流出）**。同理，**远方的服务器上的进程也相当于外部设备，需要先用socket进行标识，再通过I/O流进出数据**。**广义上来说，除了内存，其余都是外设（远端服务器，网卡，屏幕，标准输入输出等等）**
### JVM
  + 任何操作系统通过javac命令对java文件编译出来的class文件都一样，但是各个操作系统的JVM是不一样的，JVM将class文件转换成操作系统可以执行的代码。
  + 所以，我们**最终要跑一个程序，只要关注class文件是否齐全即可**。
### 包和模块
  + 一个java源文件(.java)如果被**打上包名**，那么包名也成为了**类名的一部分**，要调用该类或者运行该类，必须把包名也带上，而不是直接运行.class文件。
  + `java -d . *.java` 命令会将**包的结构**以**目录的形式**展现出来。
  + 我们调用包中的某类，重要的是**要能找到包**，ClassPath设置**包所在的那个目录**即可，不用设置到.class所在的目录，因为你不能直接调用.class文件，只能通过包去调用。（不能 java A 必须 java com.package.A）
  + 包就是一个**整体**，无论包名中有多少个"."存在，**整串字符**就是一个包名，和显示中的美国人名一样。
  + 包和目录之间是没有关系的，只不过是利用目录展示出**包的结构**。
  + 示例：F:\Java\jdk-15.0.2\bin\java.exe  -classpath "C:\Users\Penn jm\Desktop\uni\out\production\uni"(包所在位置，虽然是要类执行)  com.elesev.helloworld(带上包名才是完整的类)

### 注解Annotation
  + 注解是一个对象。
  + 注解相当于对所注解的目标添加一些额外的信息。

### 框架会不会是起了多进程（多线程），我们使用框架如果编写main的话只是起了其中一个进程（线程），其余的进程（线程）会和这个进程（线程）进行交互？（servlet 注解 和springboot annotation起作用的疑问）


